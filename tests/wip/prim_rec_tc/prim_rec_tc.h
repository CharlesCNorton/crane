#include <algorithm>
#include <any>
#include <cassert>
#include <functional>
#include <iostream>
#include <memory>
#include <optional>
#include <stdexcept>
#include <string>
#include <utility>
#include <variant>

template <typename F, typename R, typename... Args>
concept MapsTo = std::is_invocable_r_v<R, F &, Args &...>;

template <class... Ts> struct Overloaded : Ts... {
  using Ts::operator()...;
};
template <class... Ts> Overloaded(Ts...) -> Overloaded<Ts...>;

struct point {
  unsigned int px;
  unsigned int py;
};

template <typename I, typename A>
concept HasNorm = requires(A a0) {
  { I::norm(a0) } -> std::convertible_to<unsigned int>;
};

template <typename _tcI0, typename T1> unsigned int norm(const T1 _x0) {
  return _tcI0::norm(_x0);
}

struct pointNorm {
  static unsigned int norm(std::shared_ptr<point> p) { return (p->px + p->py); }
};
static_assert(HasNorm<pointNorm, std::shared_ptr<point>>);

struct vec3 {
  unsigned int vx;
  unsigned int vy;
  unsigned int vz;
};

struct vec3Norm {
  static unsigned int norm(std::shared_ptr<vec3> v) {
    return ((v->vx + v->vy) + v->vz);
  }
};
static_assert(HasNorm<vec3Norm, std::shared_ptr<vec3>>);

template <typename _tcI0, typename T1> unsigned int double_norm(const T1 x) {
  return (_tcI0::norm(x) + _tcI0::norm(x));
}

const std::shared_ptr<point> p1 = std::make_shared<point>(
    point{(((0 + 1) + 1) + 1), ((((0 + 1) + 1) + 1) + 1)});

const std::shared_ptr<point> p2 = std::make_shared<point>(point{
    ((((((((((0 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1),
    ((((((((((((((((((((0 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
              1) +
             1) +
            1) +
           1) +
          1) +
         1) +
        1) +
       1) +
      1) +
     1)});

const unsigned int test_px = p1->px;

const unsigned int test_py = p1->py;

const unsigned int test_norm_point = pointNorm::norm(p1);

const unsigned int test_double_norm =
    double_norm<pointNorm, std::shared_ptr<point>>(p1);

const std::shared_ptr<vec3> v1 =
    std::make_shared<vec3>(vec3{(0 + 1), ((0 + 1) + 1), (((0 + 1) + 1) + 1)});

const unsigned int test_norm_vec3 = vec3Norm::norm(v1);
