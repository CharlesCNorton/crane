#include <algorithm>
#include <any>
#include <cassert>
#include <functional>
#include <iostream>
#include <memory>
#include <optional>
#include <stdexcept>
#include <string>
#include <variant>

template <typename F, typename R, typename... Args>
concept MapsTo = std::is_invocable_r_v<R, F &, Args &...>;

template <class... Ts> struct Overloaded : Ts... {
  using Ts::operator()...;
};
template <class... Ts> Overloaded(Ts...) -> Overloaded<Ts...>;

struct HigherKinded {
  template <typename T1, typename T2, typename T3,
            MapsTo<T1, std::function<std::any(std::any)>, T1> F0,
            MapsTo<T3, T2> F1>
  static T1 hk_map(F0 &&map_f, F1 &&f, const T1 x) {
    return map_f("dummy", "dummy", f, x);
  }

  template <typename A> struct tree {
  public:
    struct Leaf {
      A _a0;
    };
    struct Branch {
      std::shared_ptr<tree<A>> _a0;
      std::shared_ptr<tree<A>> _a1;
    };
    using variant_t = std::variant<Leaf, Branch>;

  private:
    variant_t v_;
    explicit tree(Leaf _v) : v_(std::move(_v)) {}
    explicit tree(Branch _v) : v_(std::move(_v)) {}

  public:
    struct ctor {
      ctor() = delete;
      static std::shared_ptr<tree<A>> Leaf_(A a0) {
        return std::shared_ptr<tree<A>>(new tree<A>(Leaf{a0}));
      }
      static std::shared_ptr<tree<A>>
      Branch_(const std::shared_ptr<tree<A>> &a0,
              const std::shared_ptr<tree<A>> &a1) {
        return std::shared_ptr<tree<A>>(new tree<A>(Branch{a0, a1}));
      }
      static std::unique_ptr<tree<A>> Leaf_uptr(A a0) {
        return std::unique_ptr<tree<A>>(new tree<A>(Leaf{a0}));
      }
      static std::unique_ptr<tree<A>>
      Branch_uptr(const std::shared_ptr<tree<A>> &a0,
                  const std::shared_ptr<tree<A>> &a1) {
        return std::unique_ptr<tree<A>>(new tree<A>(Branch{a0, a1}));
      }
    };
    const variant_t &v() const { return v_; }
    variant_t &v_mut() { return v_; }
  };

  template <
      typename T1, typename T2, MapsTo<T2, T1> F0,
      MapsTo<T2, std::shared_ptr<tree<T1>>, T2, std::shared_ptr<tree<T1>>, T2>
          F1>
  static T2 Tree_rect(F0 &&f, F1 &&f0, const std::shared_ptr<tree<T1>> &t) {
    return std::visit(
        Overloaded{[&](const typename tree<T1>::Leaf _args) -> T2 {
                     T1 y = _args._a0;
                     return f(y);
                   },
                   [&](const typename tree<T1>::Branch _args) -> T2 {
                     std::shared_ptr<tree<T1>> t0 = _args._a0;
                     std::shared_ptr<tree<T1>> t1 = _args._a1;
                     return f0(t0, Tree_rect<T1, T2>(f, f0, t0), t1,
                               Tree_rect<T1, T2>(f, f0, t1));
                   }},
        t->v());
  }

  template <
      typename T1, typename T2, MapsTo<T2, T1> F0,
      MapsTo<T2, std::shared_ptr<tree<T1>>, T2, std::shared_ptr<tree<T1>>, T2>
          F1>
  static T2 Tree_rec(F0 &&f, F1 &&f0, const std::shared_ptr<tree<T1>> &t) {
    return std::visit(
        Overloaded{[&](const typename tree<T1>::Leaf _args) -> T2 {
                     T1 y = _args._a0;
                     return f(y);
                   },
                   [&](const typename tree<T1>::Branch _args) -> T2 {
                     std::shared_ptr<tree<T1>> t0 = _args._a0;
                     std::shared_ptr<tree<T1>> t1 = _args._a1;
                     return f0(t0, Tree_rec<T1, T2>(f, f0, t0), t1,
                               Tree_rec<T1, T2>(f, f0, t1));
                   }},
        t->v());
  }

  template <typename T1, typename T2, MapsTo<T2, T1> F0>
  static std::shared_ptr<tree<T2>>
  tree_map(F0 &&f, const std::shared_ptr<tree<T1>> &t) {
    return std::visit(Overloaded{[&](const typename tree<T1>::Leaf _args)
                                     -> std::shared_ptr<tree<T2>> {
                                   T1 x = _args._a0;
                                   return tree<T2>::ctor::Leaf_(f(x));
                                 },
                                 [&](const typename tree<T1>::Branch _args)
                                     -> std::shared_ptr<tree<T2>> {
                                   std::shared_ptr<tree<T1>> l = _args._a0;
                                   std::shared_ptr<tree<T1>> r = _args._a1;
                                   return tree<T2>::ctor::Branch_(
                                       tree_map<T1, T2>(f, std::move(l)),
                                       tree_map<T1, T2>(f, std::move(r)));
                                 }},
                      t->v());
  }

  template <typename T1, typename T2, MapsTo<T2, T1> F0, MapsTo<T2, T2, T2> F1>
  static T2 tree_fold(F0 &&leaf_f, F1 &&branch_f,
                      const std::shared_ptr<tree<T1>> &t) {
    return std::visit(
        Overloaded{[&](const typename tree<T1>::Leaf _args) -> T2 {
                     T1 x = _args._a0;
                     return leaf_f(x);
                   },
                   [&](const typename tree<T1>::Branch _args) -> T2 {
                     std::shared_ptr<tree<T1>> l = _args._a0;
                     std::shared_ptr<tree<T1>> r = _args._a1;
                     return branch_f(
                         tree_fold<T1, T2>(leaf_f, branch_f, std::move(l)),
                         tree_fold<T1, T2>(leaf_f, branch_f, std::move(r)));
                   }},
        t->v());
  }

  static unsigned int tree_sum(const std::shared_ptr<tree<unsigned int>> &t);

  template <typename T1>
  static unsigned int tree_size(const std::shared_ptr<tree<T1>> &t) {
    return tree_fold<T1, unsigned int>(
        [](T1 _x) { return (0 + 1); },
        [](const unsigned int _x0, const unsigned int _x1) {
          return (_x0 + _x1);
        },
        t);
  }

  template <typename T1, typename T2, MapsTo<T2, T1> F0>
  static std::optional<T2> map_option(F0 &&f, const std::optional<T1> o) {
    if (o.has_value()) {
      T1 x = *o;
      return std::make_optional<T2>(f(x));
    } else {
      return std::nullopt;
    }
  }

  static inline const std::shared_ptr<tree<unsigned int>> test_tree =
      tree<unsigned int>::ctor::Branch_(
          tree<unsigned int>::ctor::Leaf_((0 + 1)),
          tree<unsigned int>::ctor::Branch_(
              tree<unsigned int>::ctor::Leaf_(((0 + 1) + 1)),
              tree<unsigned int>::ctor::Leaf_((((0 + 1) + 1) + 1))));

  static inline const unsigned int test_tree_sum = tree_sum(test_tree);

  static inline const unsigned int test_tree_size =
      tree_size<unsigned int>(test_tree);

  static inline const std::shared_ptr<tree<unsigned int>> test_tree_map =
      tree_map<unsigned int, unsigned int>(
          [](unsigned int n) { return (n * ((0 + 1) + 1)); }, test_tree);

  static inline const std::optional<unsigned int> test_hk_option =
      hk_map<unsigned int, unsigned int>(
          [](void) { return map_option; }(),
          [](unsigned int n) { return (n + (0 + 1)); },
          std::make_optional<unsigned int>((((((0 + 1) + 1) + 1) + 1) + 1)));

  static inline const std::shared_ptr<tree<unsigned int>> test_hk_tree =
      hk_map<unsigned int, unsigned int>(
          [](void) { return tree_map; }(),
          [](unsigned int n) {
            return (
                n +
                ((((((((((0 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1));
          },
          test_tree);
};
