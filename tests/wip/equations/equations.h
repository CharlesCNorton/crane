#include <algorithm>
#include <any>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <functional>
#include <iostream>
#include <memory>
#include <optional>
#include <persistent_array.h>
#include <stdexcept>
#include <string>
#include <utility>
#include <variant>

template <typename F, typename R, typename... Args>
concept MapsTo = std::is_invocable_r_v<R, F &, Args &...>;

template <class... Ts> struct Overloaded : Ts... {
  using Ts::operator()...;
};
template <class... Ts> Overloaded(Ts...) -> Overloaded<Ts...>;

struct Nat {
  static bool leb(const unsigned int n, const unsigned int m);

  static bool ltb(const unsigned int n, const unsigned int m);

  static bool even(const unsigned int n);

  static unsigned int div2(const unsigned int n);
};

template <typename I, typename A>
concept FunctionalInduction = requires {
  { I::fun_ind_prf() } -> std::convertible_to<std::any>;
};

template <typename T1, typename T2, MapsTo<T2, T1, std::function<T2(T1)>> F0>
T2 FixWf(F0 &&step, const T1 x) {
  return step(x, [&](T1 y) { return FixWf<T1, T2>(step, y); });
}

struct Equations {
  template <MapsTo<unsigned int, unsigned int> F2>
  static unsigned int collatz_steps_clause_3(const unsigned int n,
                                             const bool refine,
                                             F2 &&collatz_steps0) {
    if (refine) {
      return (collatz_steps0(Nat::div2(std::move(n)), "dummy") + 1);
    } else {
      return (collatz_steps0((((((0 + 1) + 1) + 1) * std::move(n)) + (0 + 1)),
                             "dummy") +
              1);
    }
  }

  template <MapsTo<unsigned int, unsigned int> F1>
  static unsigned int collatz_steps_functional(const unsigned int n,
                                               F1 &&collatz_steps0) {
    if (n <= 0) {
      return 0;
    } else {
      unsigned int n0 = n - 1;
      if (n0 <= 0) {
        return 0;
      } else {
        unsigned int n1 = n0 - 1;
        return collatz_steps_clause_3(n1, Nat::even(((n1 + 1) + 1)),
                                      collatz_steps0);
      }
    }
  }

  static unsigned int collatz_steps(const unsigned int);

  static unsigned int collatz_steps_unfold_clause_3(const unsigned int n,
                                                    const bool refine);

  static unsigned int collatz_steps_unfold(const unsigned int n);

  struct collatz_steps_graph;
  struct collatz_steps_clause_3_graph;
  struct collatz_steps_graph {
  public:
    struct collatz_steps_graph_equation_1 {};
    struct collatz_steps_graph_equation_2 {};
    struct collatz_steps_graph_refinement_3 {
      unsigned int _a0;
      std::shared_ptr<collatz_steps_clause_3_graph> _a1;
    };
    using variant_t = std::variant<collatz_steps_graph_equation_1,
                                   collatz_steps_graph_equation_2,
                                   collatz_steps_graph_refinement_3>;

  private:
    variant_t v_;
    explicit collatz_steps_graph(collatz_steps_graph_equation_1 _v)
        : v_(std::move(_v)) {}
    explicit collatz_steps_graph(collatz_steps_graph_equation_2 _v)
        : v_(std::move(_v)) {}
    explicit collatz_steps_graph(collatz_steps_graph_refinement_3 _v)
        : v_(std::move(_v)) {}

  public:
    struct ctor {
      ctor() = delete;
      static std::shared_ptr<collatz_steps_graph>
      collatz_steps_graph_equation_1_() {
        return std::shared_ptr<collatz_steps_graph>(
            new collatz_steps_graph(collatz_steps_graph_equation_1{}));
      }
      static std::shared_ptr<collatz_steps_graph>
      collatz_steps_graph_equation_2_() {
        return std::shared_ptr<collatz_steps_graph>(
            new collatz_steps_graph(collatz_steps_graph_equation_2{}));
      }
      static std::shared_ptr<collatz_steps_graph>
      collatz_steps_graph_refinement_3_(
          unsigned int a0,
          const std::shared_ptr<collatz_steps_clause_3_graph> &a1) {
        return std::shared_ptr<collatz_steps_graph>(
            new collatz_steps_graph(collatz_steps_graph_refinement_3{a0, a1}));
      }
      static std::unique_ptr<collatz_steps_graph>
      collatz_steps_graph_equation_1_uptr() {
        return std::unique_ptr<collatz_steps_graph>(
            new collatz_steps_graph(collatz_steps_graph_equation_1{}));
      }
      static std::unique_ptr<collatz_steps_graph>
      collatz_steps_graph_equation_2_uptr() {
        return std::unique_ptr<collatz_steps_graph>(
            new collatz_steps_graph(collatz_steps_graph_equation_2{}));
      }
      static std::unique_ptr<collatz_steps_graph>
      collatz_steps_graph_refinement_3_uptr(
          unsigned int a0,
          const std::shared_ptr<collatz_steps_clause_3_graph> &a1) {
        return std::unique_ptr<collatz_steps_graph>(
            new collatz_steps_graph(collatz_steps_graph_refinement_3{a0, a1}));
      }
    };
    const variant_t &v() const { return v_; }
    variant_t &v_mut() { return v_; }
  };
  struct collatz_steps_clause_3_graph {
  public:
    struct collatz_steps_clause_3_graph_equation_1 {
      unsigned int _a0;
      std::shared_ptr<collatz_steps_graph> _a1;
    };
    struct collatz_steps_clause_3_graph_equation_2 {
      unsigned int _a0;
      std::shared_ptr<collatz_steps_graph> _a1;
    };
    using variant_t = std::variant<collatz_steps_clause_3_graph_equation_1,
                                   collatz_steps_clause_3_graph_equation_2>;

  private:
    variant_t v_;
    explicit collatz_steps_clause_3_graph(
        collatz_steps_clause_3_graph_equation_1 _v)
        : v_(std::move(_v)) {}
    explicit collatz_steps_clause_3_graph(
        collatz_steps_clause_3_graph_equation_2 _v)
        : v_(std::move(_v)) {}

  public:
    struct ctor {
      ctor() = delete;
      static std::shared_ptr<collatz_steps_clause_3_graph>
      collatz_steps_clause_3_graph_equation_1_(
          unsigned int a0, const std::shared_ptr<collatz_steps_graph> &a1) {
        return std::shared_ptr<collatz_steps_clause_3_graph>(
            new collatz_steps_clause_3_graph(
                collatz_steps_clause_3_graph_equation_1{a0, a1}));
      }
      static std::shared_ptr<collatz_steps_clause_3_graph>
      collatz_steps_clause_3_graph_equation_2_(
          unsigned int a0, const std::shared_ptr<collatz_steps_graph> &a1) {
        return std::shared_ptr<collatz_steps_clause_3_graph>(
            new collatz_steps_clause_3_graph(
                collatz_steps_clause_3_graph_equation_2{a0, a1}));
      }
      static std::unique_ptr<collatz_steps_clause_3_graph>
      collatz_steps_clause_3_graph_equation_1_uptr(
          unsigned int a0, const std::shared_ptr<collatz_steps_graph> &a1) {
        return std::unique_ptr<collatz_steps_clause_3_graph>(
            new collatz_steps_clause_3_graph(
                collatz_steps_clause_3_graph_equation_1{a0, a1}));
      }
      static std::unique_ptr<collatz_steps_clause_3_graph>
      collatz_steps_clause_3_graph_equation_2_uptr(
          unsigned int a0, const std::shared_ptr<collatz_steps_graph> &a1) {
        return std::unique_ptr<collatz_steps_clause_3_graph>(
            new collatz_steps_clause_3_graph(
                collatz_steps_clause_3_graph_equation_2{a0, a1}));
      }
    };
    const variant_t &v() const { return v_; }
    variant_t &v_mut() { return v_; }
  };

  template <
      typename T1, typename T2,
      MapsTo<T1, unsigned int, std::shared_ptr<collatz_steps_clause_3_graph>,
             T2>
          F2,
      MapsTo<T2, unsigned int, std::shared_ptr<collatz_steps_graph>, T1> F3,
      MapsTo<T2, unsigned int, std::shared_ptr<collatz_steps_graph>, T1> F4>
  static T1
  collatz_steps_graph_mut(const T1 f, const T1 f0, F2 &&f1, F3 &&f2, F4 &&f3,
                          std::shared_ptr<collatz_steps_graph> _x0,
                          const unsigned int _x1, const unsigned int _x2) {
    std::function<T1(unsigned int, unsigned int,
                     std::shared_ptr<collatz_steps_graph>)>
        f4;
    std::function<T2(unsigned int, bool, unsigned int,
                     std::shared_ptr<collatz_steps_clause_3_graph>)>
        f4;
    f4 = [&](unsigned int _x, unsigned int _x3,
             std::shared_ptr<collatz_steps_graph> c) -> T1 {
      return std::visit(
          Overloaded{
              [](const typename collatz_steps_graph::
                     collatz_steps_graph_equation_1 _args) -> T1 {
                return BadCPPVar;
              },
              [&](const typename collatz_steps_graph::
                      collatz_steps_graph_equation_2 _args) -> T1 { return f; },
              [&](const typename collatz_steps_graph::
                      collatz_steps_graph_refinement_3 _args) -> T1 {
                unsigned int n = _args._a0;
                std::shared_ptr<collatz_steps_clause_3_graph> hind = _args._a1;
                return f0(n, hind,
                          f4(n, Nat::even(((n + 1) + 1)),
                             collatz_steps_unfold_clause_3(
                                 n, Nat::even(((n + 1) + 1))),
                             hind));
              }},
          c->v());
    };
    f4 = [&](unsigned int _x, bool _x3, unsigned int _x4,
             std::shared_ptr<collatz_steps_clause_3_graph> c) -> T2 {
      return std::visit(
          Overloaded{
              [&](const typename collatz_steps_clause_3_graph::
                      collatz_steps_clause_3_graph_equation_1 _args) -> T2 {
                unsigned int n = _args._a0;
                std::shared_ptr<collatz_steps_graph> hind = _args._a1;
                return f1(n, hind,
                          _x2(Nat::div2(n), collatz_steps(Nat::div2(n)), hind));
              },
              [&](const typename collatz_steps_clause_3_graph::
                      collatz_steps_clause_3_graph_equation_2 _args) -> T2 {
                unsigned int n = _args._a0;
                std::shared_ptr<collatz_steps_graph> hind = _args._a1;
                return f2(
                    n, hind,
                    _x2((((((0 + 1) + 1) + 1) * n) + (0 + 1)),
                        collatz_steps((((((0 + 1) + 1) + 1) * n) + (0 + 1))),
                        hind));
              }},
          c->v());
    };
    return f4(_x0, _x1, _x2);
  }

  template <
      typename T1, typename T2,
      MapsTo<T1, unsigned int, std::shared_ptr<collatz_steps_clause_3_graph>,
             T2>
          F2,
      MapsTo<T2, unsigned int, std::shared_ptr<collatz_steps_graph>, T1> F3,
      MapsTo<T2, unsigned int, std::shared_ptr<collatz_steps_graph>, T1> F4>
  static T2 collatz_steps_clause_3_graph_mut(
      const T1 f, const T1 f0, F2 &&f1, F3 &&f2, F4 &&f3,
      std::shared_ptr<collatz_steps_clause_3_graph> _x0, const unsigned int _x1,
      const bool _x2, const unsigned int _x3) {
    std::function<T1(unsigned int, unsigned int,
                     std::shared_ptr<collatz_steps_graph>)>
        f4;
    std::function<T2(unsigned int, bool, unsigned int,
                     std::shared_ptr<collatz_steps_clause_3_graph>)>
        f4;
    f4 = [&](unsigned int _x, unsigned int _x4,
             std::shared_ptr<collatz_steps_graph> c) -> T1 {
      return std::visit(
          Overloaded{
              [](const typename collatz_steps_graph::
                     collatz_steps_graph_equation_1 _args) -> T1 {
                return BadCPPVar;
              },
              [&](const typename collatz_steps_graph::
                      collatz_steps_graph_equation_2 _args) -> T1 { return f; },
              [&](const typename collatz_steps_graph::
                      collatz_steps_graph_refinement_3 _args) -> T1 {
                unsigned int n = _args._a0;
                std::shared_ptr<collatz_steps_clause_3_graph> hind = _args._a1;
                return f0(n, hind,
                          f4(n, Nat::even(((n + 1) + 1)),
                             collatz_steps_unfold_clause_3(
                                 n, Nat::even(((n + 1) + 1))),
                             hind));
              }},
          c->v());
    };
    f4 = [&](unsigned int _x, bool _x4, unsigned int _x5,
             std::shared_ptr<collatz_steps_clause_3_graph> c) -> T2 {
      return std::visit(
          Overloaded{
              [&](const typename collatz_steps_clause_3_graph::
                      collatz_steps_clause_3_graph_equation_1 _args) -> T2 {
                unsigned int n = _args._a0;
                std::shared_ptr<collatz_steps_graph> hind = _args._a1;
                return f1(n, hind,
                          _x3(Nat::div2(n), collatz_steps(Nat::div2(n)), hind));
              },
              [&](const typename collatz_steps_clause_3_graph::
                      collatz_steps_clause_3_graph_equation_2 _args) -> T2 {
                unsigned int n = _args._a0;
                std::shared_ptr<collatz_steps_graph> hind = _args._a1;
                return f2(
                    n, hind,
                    _x3((((((0 + 1) + 1) + 1) * n) + (0 + 1)),
                        collatz_steps((((((0 + 1) + 1) + 1) * n) + (0 + 1))),
                        hind));
              }},
          c->v());
    };
    return f4(_x0, _x1, _x2, _x3);
  }

  template <
      typename T1, typename T2,
      MapsTo<T2, unsigned int, std::shared_ptr<collatz_steps_graph>, T1> F3,
      MapsTo<T2, unsigned int, std::shared_ptr<collatz_steps_graph>, T1> F4,
      MapsTo<T1, unsigned int, std::shared_ptr<collatz_steps_clause_3_graph>,
             T2>
          F5>
  static T1
  collatz_steps_graph_rect(const std::shared_ptr<collatz_steps_graph> &_x0,
                           const unsigned int _x1, const unsigned int _x2,
                           F3 &&_x3, F4 &&_x4, F5 &&_x5, const T1 _x6,
                           const T1 _x7) {
    return collatz_steps_graph_mut(_x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
  }

  static std::shared_ptr<collatz_steps_graph>
  collatz_steps_graph_correct(const unsigned int n);

  template <typename T1, MapsTo<T1, unsigned int, T1> F2,
            MapsTo<T1, unsigned int, T1> F3>
  static T1 collatz_steps_elim(const T1 f, const T1 f0, F2 &&f2, F3 &&f3,
                               const unsigned int n) {
    return collatz_steps_graph_mut(
        f, f0,
        [](unsigned int _x, std::shared_ptr<collatz_steps_clause_3_graph> _x0,
           T1 x) { return x("dummy"); },
        [&](unsigned int n0, std::shared_ptr<collatz_steps_graph> _x) {
          return f2(n0);
        },
        [&](unsigned int n0, std::shared_ptr<collatz_steps_graph> _x) {
          return f3(n0);
        },
        n, collatz_steps(n), collatz_steps_graph_correct(n));
  }

  template <MapsTo<std::any, unsigned int, std::any> F1,
            MapsTo<std::any, unsigned int, std::any> F2>
  static std::any FunctionalElimination_collatz_steps(const unsigned int _x0,
                                                      F1 &&_x1, F2 &&_x2,
                                                      const std::any _x3,
                                                      const std::any _x4) {
    return collatz_steps_elim(_x0, _x1, _x2, _x3, _x4);
  }

  struct FunctionalInduction_collatz_steps {
    static std::any fun_ind_prf() { return collatz_steps_graph_correct; }
  };
  static_assert(FunctionalInduction<FunctionalInduction_collatz_steps,
                                    std::function<unsigned int(unsigned int)>>);

  template <MapsTo<unsigned int, std::pair<unsigned int, unsigned int>> F3>
  static unsigned int gcd_clause_3(const unsigned int n, const unsigned int n0,
                                   const bool refine, F3 &&gcd0) {
    if (refine) {
      return gcd0(
          std::make_pair((n + 1),
                         ((((std::move(n0) + 1) - (n + 1)) > (std::move(n0) + 1)
                               ? 0
                               : ((std::move(n0) + 1) - (n + 1))))),
          "dummy");
    } else {
      return gcd0(
          std::make_pair(((((std::move(n) + 1) - (n0 + 1)) > (std::move(n) + 1)
                               ? 0
                               : ((std::move(n) + 1) - (n0 + 1)))),
                         (n0 + 1)),
          "dummy");
    }
  }

  template <MapsTo<unsigned int, std::pair<unsigned int, unsigned int>> F1>
  static unsigned int
  gcd_functional(const std::pair<unsigned int, unsigned int> p, F1 &&gcd0) {
    unsigned int n = p.first;
    unsigned int n0 = p.second;
    if (n <= 0) {
      return 0;
    } else {
      unsigned int n1 = n - 1;
      if (n0 <= 0) {
        return 0;
      } else {
        unsigned int n2 = n0 - 1;
        return gcd_clause_3(n1, n2, Nat::ltb((n1 + 1), (n2 + 1)), gcd0);
      }
    }
  }

  static unsigned int gcd(const std::pair<unsigned int, unsigned int>);

  static unsigned int gcd_unfold_clause_3(const unsigned int n,
                                          const unsigned int n0,
                                          const bool refine);

  static unsigned int gcd_unfold(const std::pair<unsigned int, unsigned int> p);

  struct gcd_graph;
  struct gcd_clause_3_graph;
  struct gcd_graph {
  public:
    struct gcd_graph_equation_1 {
      unsigned int _a0;
    };
    struct gcd_graph_equation_2 {
      unsigned int _a0;
    };
    struct gcd_graph_refinement_3 {
      unsigned int _a0;
      unsigned int _a1;
      std::shared_ptr<gcd_clause_3_graph> _a2;
    };
    using variant_t = std::variant<gcd_graph_equation_1, gcd_graph_equation_2,
                                   gcd_graph_refinement_3>;

  private:
    variant_t v_;
    explicit gcd_graph(gcd_graph_equation_1 _v) : v_(std::move(_v)) {}
    explicit gcd_graph(gcd_graph_equation_2 _v) : v_(std::move(_v)) {}
    explicit gcd_graph(gcd_graph_refinement_3 _v) : v_(std::move(_v)) {}

  public:
    struct ctor {
      ctor() = delete;
      static std::shared_ptr<gcd_graph> gcd_graph_equation_1_(unsigned int a0) {
        return std::shared_ptr<gcd_graph>(
            new gcd_graph(gcd_graph_equation_1{a0}));
      }
      static std::shared_ptr<gcd_graph> gcd_graph_equation_2_(unsigned int a0) {
        return std::shared_ptr<gcd_graph>(
            new gcd_graph(gcd_graph_equation_2{a0}));
      }
      static std::shared_ptr<gcd_graph>
      gcd_graph_refinement_3_(unsigned int a0, unsigned int a1,
                              const std::shared_ptr<gcd_clause_3_graph> &a2) {
        return std::shared_ptr<gcd_graph>(
            new gcd_graph(gcd_graph_refinement_3{a0, a1, a2}));
      }
      static std::unique_ptr<gcd_graph>
      gcd_graph_equation_1_uptr(unsigned int a0) {
        return std::unique_ptr<gcd_graph>(
            new gcd_graph(gcd_graph_equation_1{a0}));
      }
      static std::unique_ptr<gcd_graph>
      gcd_graph_equation_2_uptr(unsigned int a0) {
        return std::unique_ptr<gcd_graph>(
            new gcd_graph(gcd_graph_equation_2{a0}));
      }
      static std::unique_ptr<gcd_graph> gcd_graph_refinement_3_uptr(
          unsigned int a0, unsigned int a1,
          const std::shared_ptr<gcd_clause_3_graph> &a2) {
        return std::unique_ptr<gcd_graph>(
            new gcd_graph(gcd_graph_refinement_3{a0, a1, a2}));
      }
    };
    const variant_t &v() const { return v_; }
    variant_t &v_mut() { return v_; }
  };
  struct gcd_clause_3_graph {
  public:
    struct gcd_clause_3_graph_equation_1 {
      unsigned int _a0;
      unsigned int _a1;
      std::shared_ptr<gcd_graph> _a2;
    };
    struct gcd_clause_3_graph_equation_2 {
      unsigned int _a0;
      unsigned int _a1;
      std::shared_ptr<gcd_graph> _a2;
    };
    using variant_t = std::variant<gcd_clause_3_graph_equation_1,
                                   gcd_clause_3_graph_equation_2>;

  private:
    variant_t v_;
    explicit gcd_clause_3_graph(gcd_clause_3_graph_equation_1 _v)
        : v_(std::move(_v)) {}
    explicit gcd_clause_3_graph(gcd_clause_3_graph_equation_2 _v)
        : v_(std::move(_v)) {}

  public:
    struct ctor {
      ctor() = delete;
      static std::shared_ptr<gcd_clause_3_graph>
      gcd_clause_3_graph_equation_1_(unsigned int a0, unsigned int a1,
                                     const std::shared_ptr<gcd_graph> &a2) {
        return std::shared_ptr<gcd_clause_3_graph>(
            new gcd_clause_3_graph(gcd_clause_3_graph_equation_1{a0, a1, a2}));
      }
      static std::shared_ptr<gcd_clause_3_graph>
      gcd_clause_3_graph_equation_2_(unsigned int a0, unsigned int a1,
                                     const std::shared_ptr<gcd_graph> &a2) {
        return std::shared_ptr<gcd_clause_3_graph>(
            new gcd_clause_3_graph(gcd_clause_3_graph_equation_2{a0, a1, a2}));
      }
      static std::unique_ptr<gcd_clause_3_graph>
      gcd_clause_3_graph_equation_1_uptr(unsigned int a0, unsigned int a1,
                                         const std::shared_ptr<gcd_graph> &a2) {
        return std::unique_ptr<gcd_clause_3_graph>(
            new gcd_clause_3_graph(gcd_clause_3_graph_equation_1{a0, a1, a2}));
      }
      static std::unique_ptr<gcd_clause_3_graph>
      gcd_clause_3_graph_equation_2_uptr(unsigned int a0, unsigned int a1,
                                         const std::shared_ptr<gcd_graph> &a2) {
        return std::unique_ptr<gcd_clause_3_graph>(
            new gcd_clause_3_graph(gcd_clause_3_graph_equation_2{a0, a1, a2}));
      }
    };
    const variant_t &v() const { return v_; }
    variant_t &v_mut() { return v_; }
  };

  template <
      typename T1, typename T2, MapsTo<T1, unsigned int> F0,
      MapsTo<T1, unsigned int> F1,
      MapsTo<T1, unsigned int, unsigned int,
             std::shared_ptr<gcd_clause_3_graph>, T2>
          F2,
      MapsTo<T2, unsigned int, unsigned int, std::shared_ptr<gcd_graph>, T1> F3,
      MapsTo<T2, unsigned int, unsigned int, std::shared_ptr<gcd_graph>, T1> F4>
  static T1 gcd_graph_mut(F0 &&f, F1 &&f0, F2 &&f1, F3 &&f2, F4 &&f3,
                          std::shared_ptr<gcd_graph> _x0,
                          const unsigned int _x1,
                          const std::pair<unsigned int, unsigned int> _x2) {
    std::function<T1(std::pair<unsigned int, unsigned int>, unsigned int,
                     std::shared_ptr<gcd_graph>)>
        f4;
    std::function<T2(unsigned int, unsigned int, bool, unsigned int,
                     std::shared_ptr<gcd_clause_3_graph>)>
        f4;
    f4 = [&](std::pair<unsigned int, unsigned int> _x, unsigned int _x3,
             std::shared_ptr<gcd_graph> g) -> T1 {
      return std::visit(
          Overloaded{
              [](const typename gcd_graph::gcd_graph_equation_1 _args) -> T1 {
                unsigned int n0 = _args._a0;
                return BadCPPVar(std::move(n0));
              },
              [&](const typename gcd_graph::gcd_graph_equation_2 _args) -> T1 {
                unsigned int n = _args._a0;
                return f(std::move(n));
              },
              [&](const typename gcd_graph::gcd_graph_refinement_3 _args)
                  -> T1 {
                unsigned int n = _args._a0;
                unsigned int n0 = _args._a1;
                std::shared_ptr<gcd_clause_3_graph> hind = _args._a2;
                return f0(
                    n, n0, hind,
                    f4(n, n0, Nat::ltb((n + 1), (n0 + 1)),
                       gcd_unfold_clause_3(n, n0, Nat::ltb((n + 1), (n0 + 1))),
                       hind));
              }},
          g->v());
    };
    f4 = [&](unsigned int _x, unsigned int _x3, bool _x4, unsigned int _x5,
             std::shared_ptr<gcd_clause_3_graph> g) -> T2 {
      return std::visit(
          Overloaded{
              [&](const typename gcd_clause_3_graph::
                      gcd_clause_3_graph_equation_1 _args) -> T2 {
                unsigned int n = _args._a0;
                unsigned int n0 = _args._a1;
                std::shared_ptr<gcd_graph> hind = _args._a2;
                return f1(n, n0, hind,
                          _x2(std::make_pair((n + 1),
                                             ((((n0 + 1) - (n + 1)) > (n0 + 1)
                                                   ? 0
                                                   : ((n0 + 1) - (n + 1))))),
                              gcd(std::make_pair(
                                  (n + 1), ((((n0 + 1) - (n + 1)) > (n0 + 1)
                                                 ? 0
                                                 : ((n0 + 1) - (n + 1)))))),
                              hind));
              },
              [&](const typename gcd_clause_3_graph::
                      gcd_clause_3_graph_equation_2 _args) -> T2 {
                unsigned int n = _args._a0;
                unsigned int n0 = _args._a1;
                std::shared_ptr<gcd_graph> hind = _args._a2;
                return f2(
                    n, n0, hind,
                    _x2(std::make_pair(((((n + 1) - (n0 + 1)) > (n + 1)
                                             ? 0
                                             : ((n + 1) - (n0 + 1)))),
                                       (n0 + 1)),
                        gcd(std::make_pair(((((n + 1) - (n0 + 1)) > (n + 1)
                                                 ? 0
                                                 : ((n + 1) - (n0 + 1)))),
                                           (n0 + 1))),
                        hind));
              }},
          g->v());
    };
    return f4(_x0, _x1, _x2);
  }

  template <
      typename T1, typename T2, MapsTo<T1, unsigned int> F0,
      MapsTo<T1, unsigned int> F1,
      MapsTo<T1, unsigned int, unsigned int,
             std::shared_ptr<gcd_clause_3_graph>, T2>
          F2,
      MapsTo<T2, unsigned int, unsigned int, std::shared_ptr<gcd_graph>, T1> F3,
      MapsTo<T2, unsigned int, unsigned int, std::shared_ptr<gcd_graph>, T1> F4>
  static T2 gcd_clause_3_graph_mut(F0 &&f, F1 &&f0, F2 &&f1, F3 &&f2, F4 &&f3,
                                   std::shared_ptr<gcd_clause_3_graph> _x0,
                                   const unsigned int _x1, const bool _x2,
                                   const unsigned int _x3,
                                   const unsigned int _x4) {
    std::function<T1(std::pair<unsigned int, unsigned int>, unsigned int,
                     std::shared_ptr<gcd_graph>)>
        f4;
    std::function<T2(unsigned int, unsigned int, bool, unsigned int,
                     std::shared_ptr<gcd_clause_3_graph>)>
        f4;
    f4 = [&](std::pair<unsigned int, unsigned int> _x, unsigned int _x5,
             std::shared_ptr<gcd_graph> g) -> T1 {
      return std::visit(
          Overloaded{
              [](const typename gcd_graph::gcd_graph_equation_1 _args) -> T1 {
                unsigned int n0 = _args._a0;
                return BadCPPVar(std::move(n0));
              },
              [&](const typename gcd_graph::gcd_graph_equation_2 _args) -> T1 {
                unsigned int n = _args._a0;
                return f(std::move(n));
              },
              [&](const typename gcd_graph::gcd_graph_refinement_3 _args)
                  -> T1 {
                unsigned int n = _args._a0;
                unsigned int n0 = _args._a1;
                std::shared_ptr<gcd_clause_3_graph> hind = _args._a2;
                return f0(
                    n, n0, hind,
                    f4(n, n0, Nat::ltb((n + 1), (n0 + 1)),
                       gcd_unfold_clause_3(n, n0, Nat::ltb((n + 1), (n0 + 1))),
                       hind));
              }},
          g->v());
    };
    f4 = [&](unsigned int _x, unsigned int _x5, bool _x6, unsigned int _x7,
             std::shared_ptr<gcd_clause_3_graph> g) -> T2 {
      return std::visit(
          Overloaded{
              [&](const typename gcd_clause_3_graph::
                      gcd_clause_3_graph_equation_1 _args) -> T2 {
                unsigned int n = _args._a0;
                unsigned int n0 = _args._a1;
                std::shared_ptr<gcd_graph> hind = _args._a2;
                return f1(n, n0, hind,
                          _x4(std::make_pair((n + 1),
                                             ((((n0 + 1) - (n + 1)) > (n0 + 1)
                                                   ? 0
                                                   : ((n0 + 1) - (n + 1))))),
                              gcd(std::make_pair(
                                  (n + 1), ((((n0 + 1) - (n + 1)) > (n0 + 1)
                                                 ? 0
                                                 : ((n0 + 1) - (n + 1)))))),
                              hind));
              },
              [&](const typename gcd_clause_3_graph::
                      gcd_clause_3_graph_equation_2 _args) -> T2 {
                unsigned int n = _args._a0;
                unsigned int n0 = _args._a1;
                std::shared_ptr<gcd_graph> hind = _args._a2;
                return f2(
                    n, n0, hind,
                    _x4(std::make_pair(((((n + 1) - (n0 + 1)) > (n + 1)
                                             ? 0
                                             : ((n + 1) - (n0 + 1)))),
                                       (n0 + 1)),
                        gcd(std::make_pair(((((n + 1) - (n0 + 1)) > (n + 1)
                                                 ? 0
                                                 : ((n + 1) - (n0 + 1)))),
                                           (n0 + 1))),
                        hind));
              }},
          g->v());
    };
    return f4(_x0, _x1, _x2, _x3, _x4);
  }

  template <
      typename T1, typename T2,
      MapsTo<T2, unsigned int, unsigned int, std::shared_ptr<gcd_graph>, T1> F3,
      MapsTo<T2, unsigned int, unsigned int, std::shared_ptr<gcd_graph>, T1> F4,
      MapsTo<T1, unsigned int, unsigned int,
             std::shared_ptr<gcd_clause_3_graph>, T2>
          F5,
      MapsTo<T1, unsigned int> F6, MapsTo<T1, unsigned int> F7>
  static T1 gcd_graph_rect(const std::shared_ptr<gcd_graph> &_x0,
                           const unsigned int _x1,
                           const std::pair<unsigned int, unsigned int> _x2,
                           F3 &&_x3, F4 &&_x4, F5 &&_x5, F6 &&_x6, F7 &&_x7) {
    return gcd_graph_mut(_x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
  }

  static std::shared_ptr<gcd_graph>
  gcd_graph_correct(const std::pair<unsigned int, unsigned int> p);

  template <typename T1, MapsTo<T1, unsigned int> F0,
            MapsTo<T1, unsigned int> F1,
            MapsTo<T1, unsigned int, unsigned int, T1> F2,
            MapsTo<T1, unsigned int, unsigned int, T1> F3>
  static T1 gcd_elim(F0 &&f, F1 &&f0, F2 &&f2, F3 &&f3,
                     const std::pair<unsigned int, unsigned int> p) {
    return gcd_graph_mut(
        f, f0,
        [&](unsigned int _x, unsigned int _x0,
            std::shared_ptr<gcd_clause_3_graph> _x1, T1 x) {
          unsigned int _x2 = p.first;
          unsigned int _x3 = p.second;
          return x("dummy");
        },
        [&](unsigned int n1, unsigned int n2, std::shared_ptr<gcd_graph> _x) {
          unsigned int _x0 = p.first;
          unsigned int _x1 = p.second;
          return f2(n1, n2);
        },
        [&](unsigned int n1, unsigned int n2, std::shared_ptr<gcd_graph> _x) {
          unsigned int _x0 = p.first;
          unsigned int _x1 = p.second;
          return f3(n1, n2);
        },
        p, gcd(p), gcd_graph_correct(p));
  }

  template <MapsTo<std::any, unsigned int, unsigned int, std::any> F1,
            MapsTo<std::any, unsigned int, unsigned int, std::any> F2,
            MapsTo<std::any, unsigned int> F3,
            MapsTo<std::any, unsigned int> F4>
  static std::any
  FunctionalElimination_gcd(const std::pair<unsigned int, unsigned int> _x0,
                            F1 &&_x1, F2 &&_x2, F3 &&_x3, F4 &&_x4) {
    return gcd_elim(_x0, _x1, _x2, _x3, _x4);
  }

  struct FunctionalInduction_gcd {
    static std::any fun_ind_prf() { return gcd_graph_correct; }
  };
  static_assert(
      FunctionalInduction<
          FunctionalInduction_gcd,
          std::function<unsigned int(std::pair<unsigned int, unsigned int>)>>);

  static inline const unsigned int test_gcd = gcd(std::make_pair(
      ((((((((((((0 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1),
      ((((((((0 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1)));

  static inline const unsigned int test_collatz =
      collatz_steps(((((((0 + 1) + 1) + 1) + 1) + 1) + 1));
};
